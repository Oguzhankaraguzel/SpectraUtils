namespace SpectraUtils.Extensions;

/// <summary>
/// Provides unsafe string operations for callers that accept unsafe code.
/// </summary>
public static class StringExtensionsUnsafe
{
    /// <summary>
    /// Reverses the characters of the provided string using unsafe pointers.
    /// </summary>
    /// <param name="value">Input string to reverse. Cannot be null.</param>
    /// <returns>A new string containing the characters of <paramref name="value"/> in reverse order.</returns>
    /// <remarks>
    /// This method uses unsafe code and fixed pointers for maximum performance. Use only when the
    /// consumer accepts unsafe code. The project must allow unsafe blocks to compile this file.
    /// For a safe alternative, use <see cref="StringExtensions.ReverseSafe(string)"/>.
    /// </remarks>
    public static unsafe string ReverseUnsafe(this string value)
    {
        if (value is null)
            throw new ArgumentNullException(nameof(value));

        int len = value.Length;
        if (len <= 1)
            return value;

        // Allocate result string filled with '\0' characters; we'll overwrite them.
        string result = new string('\0', len);

        fixed (char* pSrc = value)
        fixed (char* pDst = result)
        {
            char* src = pSrc;
            char* dst = pDst;

            for (int i = 0; i < len; i++)
            {
                dst[i] = src[len - 1 - i];
            }
        }

        return result;
    }
    public static unsafe void ReverseInPlaceUnsafe(this string value)
    {
        if (value is null) throw new ArgumentNullException(nameof(value));
        int len = value.Length;
        if (len <= 1)
            return;

        // DİKKAT: .NET string'leri immutable olarak tasarlanmıştır.
        // Bu metot string'in bellek içeriğini doğrudan değiştirir — yalnızca
        // değiştirilen örneğin interned olmadığından ve başka yerlerde paylaşılmadığından emin olun.
        // Ayrıca UTF-16 surrogate pair'leri (emoji vb.) içeren string'lerde kod-unite
        // seviyesinde ters çevirme geçersiz UTF-16 oluşturabilir.
        fixed (char* p = value)
        {
            char* head = p;
            char* tail = p + (len - 1);

            while (head < tail)
            {
                char tmp = *head;
                *head = *tail;
                *tail = tmp;

                head++;
                tail--;
            }
        }
    }
}
